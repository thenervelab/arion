//! Core types for proof-of-storage.

use serde::{Deserialize, Serialize};
use wincode_derive::{SchemaRead, SchemaWrite};

use crate::config::DIGEST_ELEMS;

/// A hash output from Poseidon2, represented as field elements.
/// Using BabyBear field (31-bit elements), we use 8 elements for ~248 bits of security.
pub type Poseidon2Hash = [u32; DIGEST_ELEMS];

/// Challenge sent by a Warden to a Miner.
///
/// Contains the indices of chunks that the miner must prove possession of.
#[derive(Clone, Debug, Serialize, Deserialize, SchemaWrite, SchemaRead)]
pub struct Challenge {
    /// Which shard to prove (BLAKE3 hash, hex-encoded)
    pub shard_hash: String,

    /// Random chunk indices to prove possession of
    pub chunk_indices: Vec<u32>,

    /// Random nonce for freshness (prevents replay)
    pub nonce: [u8; 32],

    /// Expected Merkle root from commitment
    pub expected_root: Poseidon2Hash,

    /// Challenge expiry timestamp (Unix seconds)
    pub expires_at: u64,
}

impl Challenge {
    /// Create a new challenge for the given commitment and chunk indices.
    pub fn new(
        shard_hash: &str,
        chunk_indices: Vec<u32>,
        expected_root: Poseidon2Hash,
        expires_at: u64,
    ) -> Self {
        let mut nonce = [0u8; 32];
        // In production, use proper randomness
        for (i, byte) in nonce.iter_mut().enumerate() {
            *byte = (i as u8).wrapping_mul(37);
        }

        Self {
            shard_hash: shard_hash.to_string(),
            chunk_indices,
            nonce,
            expected_root,
            expires_at,
        }
    }

    /// Validate that all chunk indices are within bounds.
    pub fn validate(&self, chunk_count: u32) -> crate::Result<()> {
        for &idx in &self.chunk_indices {
            if idx >= chunk_count {
                return Err(crate::PosError::ChunkIndexOutOfBounds {
                    index: idx,
                    max: chunk_count - 1,
                });
            }
        }
        Ok(())
    }
}

/// Public inputs to the proof-of-storage circuit.
///
/// These are the values that the verifier checks against.
#[derive(Clone, Debug, Serialize, Deserialize, SchemaWrite, SchemaRead)]
pub struct PublicInputs {
    /// The Merkle root being proven against
    pub merkle_root: Poseidon2Hash,

    /// The chunk indices that were challenged
    pub chunk_indices: Vec<u32>,

    /// The Poseidon2 hashes of the challenged chunks
    pub chunk_hashes: Vec<Poseidon2Hash>,
}

impl PublicInputs {
    /// Convert public inputs to a flat vector of u32 for the circuit.
    pub fn to_vec(&self) -> Vec<u32> {
        let mut result = Vec::new();

        // Merkle root (DIGEST_ELEMS elements)
        result.extend_from_slice(&self.merkle_root);

        // For each challenge: index + hash (1 + DIGEST_ELEMS elements)
        for (idx, hash) in self.chunk_indices.iter().zip(self.chunk_hashes.iter()) {
            result.push(*idx);
            result.extend_from_slice(hash);
        }

        result
    }

    /// Parse public inputs from a flat vector.
    pub fn from_vec(data: &[u32], num_challenges: usize) -> crate::Result<Self> {
        let expected_len = DIGEST_ELEMS + num_challenges * (1 + DIGEST_ELEMS);
        if data.len() != expected_len {
            return Err(crate::PosError::InvalidProofFormat(format!(
                "Expected {} public inputs, got {}",
                expected_len,
                data.len()
            )));
        }

        let merkle_root: Poseidon2Hash = data[0..DIGEST_ELEMS].try_into().unwrap();

        let mut chunk_indices = Vec::with_capacity(num_challenges);
        let mut chunk_hashes = Vec::with_capacity(num_challenges);

        for i in 0..num_challenges {
            let offset = DIGEST_ELEMS + i * (1 + DIGEST_ELEMS);
            chunk_indices.push(data[offset]);
            let hash: Poseidon2Hash = data[offset + 1..offset + 1 + DIGEST_ELEMS]
                .try_into()
                .unwrap();
            chunk_hashes.push(hash);
        }

        Ok(Self {
            merkle_root,
            chunk_indices,
            chunk_hashes,
        })
    }
}

/// A proof-of-storage proof generated by a miner.
#[derive(Clone, Debug, Serialize, Deserialize, SchemaWrite, SchemaRead)]
pub struct Proof {
    /// Serialized Plonky3 STARK proof
    pub proof_bytes: Vec<u8>,

    /// Public inputs used in the proof
    pub public_inputs: PublicInputs,

    /// Number of challenges in this proof
    pub num_challenges: usize,

    /// Time taken to generate the proof (milliseconds)
    pub proving_time_ms: u64,
}

impl Proof {
    /// Get the Merkle root from the proof's public inputs.
    pub fn merkle_root(&self) -> &Poseidon2Hash {
        &self.public_inputs.merkle_root
    }

    /// Get the chunk indices that were proven.
    pub fn chunk_indices(&self) -> &[u32] {
        &self.public_inputs.chunk_indices
    }

    /// Serialize the proof to bytes.
    pub fn to_bytes(&self) -> crate::Result<Vec<u8>> {
        wincode::serialize(self).map_err(Into::into)
    }

    /// Deserialize a proof from bytes.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        wincode::deserialize(bytes).map_err(Into::into)
    }
}

/// Merkle proof for a single chunk.
///
/// Contains the sibling hashes needed to verify a leaf against the root.
#[derive(Clone, Debug, Serialize, Deserialize, SchemaWrite, SchemaRead)]
pub struct MerkleProof {
    /// Index of the leaf in the tree
    pub leaf_index: u32,

    /// Sibling hashes from leaf to root
    pub siblings: Vec<Poseidon2Hash>,
}

impl MerkleProof {
    /// Get the depth of this proof (number of levels in the tree).
    pub fn depth(&self) -> usize {
        self.siblings.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_public_inputs_roundtrip() {
        let inputs = PublicInputs {
            merkle_root: [1, 2, 3, 4, 5, 6, 7, 8],
            chunk_indices: vec![10, 20, 30, 40],
            chunk_hashes: vec![
                [5, 6, 7, 8, 9, 10, 11, 12],
                [13, 14, 15, 16, 17, 18, 19, 20],
                [21, 22, 23, 24, 25, 26, 27, 28],
                [29, 30, 31, 32, 33, 34, 35, 36],
            ],
        };

        let vec = inputs.to_vec();
        let recovered = PublicInputs::from_vec(&vec, 4).unwrap();

        assert_eq!(inputs.merkle_root, recovered.merkle_root);
        assert_eq!(inputs.chunk_indices, recovered.chunk_indices);
        assert_eq!(inputs.chunk_hashes, recovered.chunk_hashes);
    }

    #[test]
    fn test_challenge_validation() {
        let challenge = Challenge::new("test", vec![0, 5, 10], [0; DIGEST_ELEMS], u64::MAX);

        assert!(challenge.validate(20).is_ok());
        assert!(challenge.validate(10).is_err()); // index 10 is out of bounds for 10 chunks
    }
}
